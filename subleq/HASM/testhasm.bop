// =======================================================//
// Projet Systèmes Numériques - ENS, semestre 2           //
// Mathieu Barbin, Mehdi Bouaziz.                         //
// TESTHASM : meta-code pour boptest 		          //
// VERSION : Samedi 15 mars		                  //
// =======================================================//

// boptest this_file : produit un source cible pret à etre compiler
// une fois compile, c'est un executable à piper à simu (bops) 
// permet du pretty printing, et debug

#source = ocaml  // autre possibilite = C : bof ou sous classe

// Acces aux macros depuis du code source : _CL, _AR
#define AR 4
#define CL 3

// Eventuellement, creation d'une ram en meta avec valeur
// #RAM MEM (AR, AR) = text { } : accessible sous un objet _MEM dans le code

// Init  
#init %{

#load "graphics.cma";;
#load "classram.cmo";; 

  open Graphics;;

  let _AR = 4;;

  (* Ceci est du code Ocaml appele une seule fois *) 
  let ( *$ ) a n = 
    let rec aux accu i = 
      if i = 0 then accu else aux (accu * a) (pred i) in
    aux 1 n;;

  let tM = (2 *$ _AR);;
  let s = "0000100001001100001010100110";;
  
  let mem = new Classram.class_ram "SUBLEQ" _AR _AR [||];;
  mem#init;;

  let string_of_bits b = 
    let len = Array.length b in
    let s_out = String.make len ' ' in
    for i = 0 to pred len do
      s_out.[i] <- if b.(i) then '1' else '0'
    done;
    s_out;;

  let draw_mem () =
    clrscr ();
    set_color black;
    for i = 0 to pred tM do
      moveto (5 + 100*(i / 46))  (685 - (15 * (i mod 46)));
      draw_string (Printf.sprintf "%4d : %s" i (string_of_bits mem.(i)))
    done;;

  let pc_ml = Array.create _AR false;; 
  
  (* On introduit des fonctions qui peuvent nous servir dans la validation *)
  let reg_maker () = 
    let d = ref false in 
    (function t -> let o = !d in (d :=t; o));;
  
  let reg1 = reg_maker ();;
}%

// On copie l'interface 
#test SUBLEQ (
	// ENTREES : 
	clk_in, run, set_pc, pc_in:[AR], write, 
	read_adress:[AR], write_adress:[AR], data_in:[AR] ) 
	// SORTIES :
	= ( _ICY:[CL], pc_out:[AR], data_out:[AR], _LSL_NEW_LPC:[AR], _Lmem_mod, _Lmem_read:[AR] )
#with code %{
  (* Ceci est du code Ocaml executé a chaque cycle *)
  (* il doit etre de type bool signifiant la validation du cycle *)
  (* Dans ce corps, on dispose de tous les signaux types selon
     leur definition : bool, bool array, bool array array, etc... *)
  begin
    ignore (wait_next_event [Button_down]);
    draw_mem ();
    let data_out' = Array.make _AR false in
    
  if run 
   then
    begin
      Printf.printf "RUN : PC = %d, ICY = %d\n" (int_of_bits pc_out) (int_of_bits _ICY);
    end 
  else
    begin
      (* On se sert de la machine comme une RAM *)
      if write 
      then
	begin
	  let wr_a = int_of_bits write_adress in
	  for i = 0 to _AR do
	    mem.(wr_a).(i) <- data_in.(i)
	  done;
	  Printf.printf "RAM : Write mem.(%d) <- %d\n" wr_a (int_of_bits data_in)  
	end
      else
	begin
	  let rd_a = int_of_bits read_adress in
	  for i = 0 to _AR do
	    data_out'.(i) <- mem.(rd_a).(i)
	  done;
	  Printf.printf "RAM : Read mem.(%d) = %d\n" rd_a (int_of_bits data_out) 
	end 
      ;
      if set_pc
      then
	begin
	  for i = 0 to _AR do
	    pc_ml.(i) <- pc_in.(i)
	  done;
	  Printf.printf "SET_PC : Write pc <- %d\n" (int_of_bits pc_in)  
	end
      else ();
      
	
    end
  ;
  true
  end
}%
